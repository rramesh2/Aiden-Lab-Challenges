\documentclass[12pt]{article}
\usepackage{fancyhdr,graphicx,amsmath,amssymb, mathtools, scrextend, titlesec, enumitem}
\usepackage[ruled,vlined]{algorithm2e}
\include{pythonlisting}
\usepackage{color, colortbl}
\usepackage{multirow}
\usepackage[normalem]{ulem}
\usepackage{tabu,multirow}
\usepackage[margin=1in]{geometry}

\title{File Challenge Questions}
\author{Santiago Garcia Acosta}

\begin{document}
\maketitle

{\raggedleft{} \textbf{a.)}} An algorithm to solve this problem would be one that reads each file into a string with delimiters and then separates the string by spaces and new line delimiters, mapping the text at the beginning of lines (identifiers) to the text at the rest of their lines. The algorithm would then iterate over the mappings for each file and compare the keys (identifiers) of one file's maps to the keys of the other file. If they are found to be identical, then the algorithm will combine their mapped statements into a new statement. The identifier would then be mapped to the new statement in a new mapping for the file that is to be produced, and write the new file once all the identifiers for both files have been compared with one another.
\\\\
\textbf{b.)} \emph{Pseudocode:}

\begin{algorithm}
\caption{filechallenge}
\KwIn{$file1$, $file2$ being file locations in the user's computer}
\hrulefill

\nl $string1 \gets$ result from reading $file1$ into a string + "\textbackslash \texttt{n}"\;
\nl $string2 \gets$ result from reading $file2$ into a string + "\textbackslash \texttt{n}"\;
\nl $strings \gets (string1, string2)$\;
\nl Initialize $map1$ to an empty mapping\;
\nl Initialize $map2$ to an empty mapping\;
\nl $maps \gets (map1, map2)$\;
\nl \For{$i\gets 0$ \KwTo 1}{
\nl $string \gets strings[i]$\;
\nl $idx \gets 0$\;
\nl $idxbase \gets 0$\;
\nl $idfound \gets 0$\;
\nl \For{$char \in string$}{
	\nl \If{$char = "\text{ } "$ \textbf{and} $idfound = 0$}{
		\nl $idfound \gets 1$\;
		\nl $idval \gets string[idxbase:idx]$\;
		\nl $idloc \gets idx$\;
	}
	\nl \If{$char = "$ \textbackslash \texttt{n} $"$ \textbf{and} $idfound = 1$}{
		\nl $maps[i]_{idval} \gets string[idloc + 1: idx]$\;
		\nl $idfound \gets 0$\;
		\nl $idxbase \gets idx + 1$\;
	}
	\nl $idx \gets idx + 1$\;
}
}
\nl $newstring \gets ""$\;
\nl \For{$delim \in maps[0]$}{
	\nl \If{$delim \in maps[1]$}{
		\nl $newstring \gets newstring + delim + "\text{ }" + maps[0]_{delim} + "\text{ }" + maps[1]_{delim} + "$  \textbackslash $\texttt{n}"$\;
	}
}
\nl $newfile \gets $ generated file from $newstring$\;
\nl \Return{$newfile$} \;
\end{algorithm}
\pagebreak

{\raggedleft{} The} pros of this approach are that it is simple and easy to understand and, of course, solves the problem given. However, it can be computationally intensive for larger file sizes as the algorithm has a running time of $O(n^2)$ where $n$ is the number of characters in the string for each file, assuming each file has the same number of characters. Another pro of this however is the ease with which it can be implemented with common day programming languages, as a lot of what is shown in the algorithm can be done in a single line using built-in functions.
\end{document}